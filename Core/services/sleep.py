# Disclaimer: This file was partially generated by AI.

import threading
import time
import datetime as dt

from utils.configuration_manager import configuration_manager
from utils.database import query
from sensors.bed_sensor import bed_sensor

# === CONFIGURABLE CONSTANTS ====================================================
SLEEP_DETECTION_seconds = 5            # Minutes of continuous bed‑presence → asleep
OVERSLEEP_HOURS = 8                    # After this many hours we assume a new sleep
OVERSLEEP_DELTA = dt.timedelta(hours=OVERSLEEP_HOURS)

# Scoring parameters — tweak these from code or expose them via configuration
MAX_DIFF_MINUTES = 120    # Bed/Wake/Sleep‑length differences that give 0 points
MAX_PHONE_MINUTES = 30    # ≥ this many minutes of phone use → 0 points
MAX_INTERRUPTS = 5         # ≥ this many exits from bed → 0 points

# Component weightings (must sum to 1.0)
WEIGHT_BEDTIME = 0.20
WEIGHT_WAKE    = 0.20
WEIGHT_DURATION = 0.30
WEIGHT_PHONE   = 0.20
WEIGHT_INTERRUPTS = 0.10


# === HELPER FUNCTIONS ==========================================================

def _linear_score(value: float, max_value: float) -> float:
    """Normalises *value* in [0, max_value] to a 100‑0 descending scale.

    0 → 100 pts, max_value → 0 pts, values > max_value clamp to 0.
    """
    if value <= 0:
        return 100.0
    score = 100.0 - (value / max_value) * 100.0
    return max(score, 0.0)


# === SERVICE ===================================================================

class SleepService:
    """Tracks nightly sleeps and calculates quality metrics when they end."""

    def __init__(self):
        self.lock = threading.Lock()
        self.stop_event = threading.Event()
        self.thread = threading.Thread(target=self._worker, daemon=True)
        self.prefix = "Sleep Service"

        self.current_sleep_id: int | None = None
        self.planned_sleep_end_time: dt.datetime | None = None
        self.planned_sleep_start_time: dt.datetime | None = None

        self.bed_sensor_active_since: dt.datetime | None = None
        self.sleeping_since = 0
        self.is_sleeping: bool = False

        # Prevent double‑start
        self._running = False

    # -------------------------------------------------------------------------
    # Convenience
    def _log(self, *args):
        print(f"[{self.prefix}]", *args)

    # -------------------------------------------------------------------------
    # Life‑cycle
    def start(self):
        """Initialises listeners and starts the background worker."""
        if self._running:
            self._log("start() called more than once – ignoring")
            return

        self._log("Starting thread…")
        bed_sensor.add_listener(self._handle_bed_sensor)
        self._create_or_get_tonight_sleep()
        self.thread.start()
        self._running = True

    # -------------------------------------------------------------------------
    # Worker loop
    def _worker(self):
        """Background tick every second for state housekeeping."""
        while not self.stop_event.is_set():
            try:
                time.sleep(1)
                now = dt.datetime.now()

                with self.lock:
                    # --- Detect transition into sleep ---------------------------
                    if (
                        not self.is_sleeping
                        and self.bed_sensor_active_since is not None
                        and self.bed_sensor_active_since < now - dt.timedelta(seconds=SLEEP_DETECTION_seconds)
                    ):
                        # Consider the user officially *asleep*
                        self.is_sleeping = True
                        self.sleeping_since = time.time()
                        if self.current_sleep_id is not None:
                            query(
                                "UPDATE sleep_history SET actual_start = COALESCE(actual_start, %s) WHERE id = %s",
                                (self.bed_sensor_active_since, self.current_sleep_id),
                            )
                            self._log("User now detected as sleeping")

                    # --- Detect oversleep/new‑day rollover ----------------------
                    if (
                        self.planned_sleep_end_time is not None
                        and not self.is_sleeping  # do not rollover while in bed
                        and self.bed_sensor_active_since is None
                        and now > self.planned_sleep_end_time + OVERSLEEP_DELTA
                    ):
                        self._create_or_get_tonight_sleep()
            except Exception as e:
                self._log("Worker error:", e, "(continuing)")

    # -------------------------------------------------------------------------
    # Sleep detection via bed sensor
    def _handle_bed_sensor(self, state: bool):
        now = dt.datetime.now()

        if state:  # Bed occupied
            with self.lock:
                if not self.is_sleeping and self.bed_sensor_active_since is None:
                    self.bed_sensor_active_since = now
                    #self._log("Bed sensor activated at:", now)
            return

        # -------------- Bed vacated --------------------
        sleep_id: int | None = None
        with self.lock:
            if self.is_sleeping:
                sleep_id = self.current_sleep_id
                # Mark sleep as finished in memory – DB work happens outside lock
            # Reset state regardless
            self.is_sleeping = False
            self.bed_sensor_active_since = None

        if sleep_id is not None:
            # Heavy DB work outside the mutex to avoid blocking other operations
            query(
                "UPDATE sleep_history SET actual_end = %s WHERE id = %s",
                (now, sleep_id),
            )
            #self._log("Bed sensor deactivated, sleep ended at:", now)
            self._finalise_sleep(now)

    # -------------------------------------------------------------------------
    # Public helpers (used by other services)
    def get_sleep_id(self) -> int | None:
        with self.lock:
            if (
                self.planned_sleep_end_time is not None
                and dt.datetime.now() > self.planned_sleep_end_time + OVERSLEEP_DELTA
                and not self.is_sleeping
            ):
                self._create_or_get_tonight_sleep()
            return self.current_sleep_id

    def get_planned_start_time(self) -> dt.datetime | None:
        with self.lock:
            return self.planned_sleep_start_time

    def get_planned_end_time(self) -> dt.datetime | None:
        with self.lock:
            return self.planned_sleep_end_time

    # -------------------------------------------------------------------------
    # Internal helpers
    def _create_or_get_tonight_sleep(self):
        """Ensures there's a *sleep_history* row for the upcoming night."""
        with self.lock:
            self.is_sleeping = False
            self.bed_sensor_active_since = None

            # Validate configuration early to avoid killing the worker thread
            try:
                sleep_goal = float(configuration_manager.get_config("ALARM", "sleep_goal"))  # hours
                wakeup_cfg = configuration_manager.get_config("ALARM", "wakeup_time")        # HH:MM
                wake_clock = dt.datetime.strptime(wakeup_cfg, "%H:%M").time()
            except Exception as e:
                self._log("Bad ALARM configuration – cannot schedule tonight's sleep:", e)
                return

            today = dt.date.today()
            planned_end = dt.datetime.combine(today, wake_clock)
            if planned_end < dt.datetime.now():
                planned_end += dt.timedelta(days=1)
            planned_start = planned_end - dt.timedelta(hours=sleep_goal)

            self.planned_sleep_end_time = planned_end
            self.planned_sleep_start_time = planned_start

        # DB queries outside the lock – gather the newly‑computed values first
        row = query(
            "SELECT id FROM sleep_history WHERE planned_end::date = %s::date LIMIT 1",
            (planned_end.date(),),
        )
        if row:
            with self.lock:
                self.current_sleep_id = row[0][0]
            self._log("Existing sleep found with ID:", self.current_sleep_id)
            return

        result = query(
            "INSERT INTO sleep_history (planned_start, planned_end, recordings_enabled, ambient_noise_enabled) "
            "VALUES (%s, %s, %s, %s) RETURNING id",
            (planned_start, planned_end, True, True),
        )
        with self.lock:
            self.current_sleep_id = result[0][0]
        self._log("Sleep created with ID:", self.current_sleep_id)

    # -------------------------------------------------------------------------
    # Metrics + scoring --------------------------------------------------------
    def _finalise_sleep(self, actual_end: dt.datetime) -> None:
        """Calculates nightly metrics & score and stores them in *sleep_history*."""
        try:
            if self.current_sleep_id is None:
                self._log("No current_sleep_id – cannot finalise sleep")
                return

            # Fetch basic timestamps ---------------------------------------
            row = query(
                "SELECT planned_start, planned_end, actual_start FROM sleep_history WHERE id = %s",
                (self.current_sleep_id,),
            )
            if not row or not row[0][2]:
                # Missing actual_start → we never confirmed bedtime; nothing to do
                return

            planned_start, planned_end, actual_start = row[0]

            # -----------------------------------------------------------------
            # Aggregate raw metrics from occupancy tables
            time_in_bed_sec = query(
                "SELECT COALESCE(SUM(duration), 0) FROM bed_occupancy WHERE sleep_id = %s",
                (self.current_sleep_id,),
            )[0][0] or 0

            total_phone_use_sec = query(
                "SELECT COALESCE(SUM(duration), 0) FROM phone_occupancy WHERE sleep_id = %s",
                (self.current_sleep_id,),
            )[0][0] or 0

            times_left_bed = query(
                "SELECT COUNT(*) FROM bed_occupancy WHERE sleep_id = %s",
                (self.current_sleep_id,),
            )[0][0] or 0

            # -----------------------------------------------------------------
            # Convert to minutes for scoring
            time_in_bed_min = time_in_bed_sec / 60.0
            phone_use_min = total_phone_use_sec / 60.0

            goal_duration_min = (planned_end - planned_start).total_seconds() / 60.0
            actual_duration_min = (actual_end - actual_start).total_seconds() / 60.0

            bedtime_diff_min = abs((actual_start - planned_start).total_seconds()) / 60.0
            wake_diff_min = abs((actual_end - planned_end).total_seconds()) / 60.0
            duration_diff_min = abs(actual_duration_min - goal_duration_min)

            # -----------------------------------------------------------------
            # Compute component scores [0–100]
            bedtime_score = _linear_score(bedtime_diff_min, MAX_DIFF_MINUTES)
            wake_score = _linear_score(wake_diff_min, MAX_DIFF_MINUTES)
            duration_score = _linear_score(duration_diff_min, MAX_DIFF_MINUTES)
            phone_score = _linear_score(phone_use_min, MAX_PHONE_MINUTES)
            interrupt_score = _linear_score(times_left_bed, MAX_INTERRUPTS)

            # Weighted aggregate ------------------------------------------------
            final_score = (
                bedtime_score * WEIGHT_BEDTIME
                + wake_score * WEIGHT_WAKE
                + duration_score * WEIGHT_DURATION
                + phone_score * WEIGHT_PHONE
                + interrupt_score * WEIGHT_INTERRUPTS
            )
            final_score_int = int(round(final_score))

            # -----------------------------------------------------------------
            # Persist back to DB ----------------------------------------------
            query(
                "UPDATE sleep_history SET score = %s, time_in_bed = %s, total_phone_use = %s WHERE id = %s",
                (final_score_int, int(time_in_bed_sec), int(total_phone_use_sec), self.current_sleep_id),
            )

            self._log(
                f"Sleep {self.current_sleep_id} scored {final_score_int} | "
                f"Time‑in‑bed: {time_in_bed_min:.1f} min | Phone: {phone_use_min:.1f} min | "
                f"Interruptions: {times_left_bed}"
            )
        except Exception as e:
            self._log("Error computing sleep metrics:", e)


# Instantiate singleton for import‑side effect convenience                       
sleep_service = SleepService()
