# Disclaimer: Microphone setup, some helper functions and recording logic were generated by AI.
import threading
import time
import sounddevice as sd
import numpy as np
from scipy.io.wavfile import write
from collections import deque
import requests
import io
from scipy.io.wavfile import write as write_wav
import json
from utils.database import query
from services.sleep import sleep_service
from utils.configuration_manager import configuration_manager

SAMPLERATE = 44100
CHANNELS = 1
CHUNK_DURATION = 0.5                 # seconds per read
CHUNK_SAMPLES = int(SAMPLERATE * CHUNK_DURATION)
THRESHOLD = 0.2                      # volume threshold (0.0 - 1.0)
PRE_BUFFER_SEC = 5                  # save this many seconds before threshold
POST_BUFFER_SEC = 5                 # keep recording this many seconds after sound drops

class RecordingsService:
    def __init__(self):
        self.lock = threading.Lock()
        self.thread = threading.Thread(target=self.worker, daemon=True)
        self.prefix = "Recordings Service"
        
        self.pre_buffer_chunks = int(PRE_BUFFER_SEC / CHUNK_DURATION)
        self.post_buffer_chunks = int(POST_BUFFER_SEC / CHUNK_DURATION)

        self.pre_buffer = deque(maxlen=self.pre_buffer_chunks)
        self.recording_buffer = []
        self.recording = False
        self.post_timer = 0
        self.warmup_counter = 0

    def print(self, *args):
        print(f"[{self.prefix}]", *args)

    def start(self):
        self.print("Starting thread...")
        self.thread.start()

    def get_volume(self, data):
        return np.sqrt(np.mean(np.square(data)))

    def record_chunk(self):
        return sd.rec(CHUNK_SAMPLES, samplerate=SAMPLERATE, channels=CHANNELS, dtype="float32")

    def upload_buffer(self, wav_data, filename):
        buffer = io.BytesIO()
        write_wav(buffer, SAMPLERATE, wav_data)
        buffer.seek(0)

        files = {"file": (filename, buffer, "audio/wav")}

        response = requests.post("http://localhost:3002/objectstorage/storage/upload", files=files)
        print(f"Server response: {response.status_code} - {response.text}")
        
        if response.status_code == 200:
            json_data = json.loads(response.text)
            file_id = json_data.get("fileId")
            
            query(f"INSERT INTO recordings (file_id, sleep_id, start_time, duration_seconds, peak_volume) VALUES ({file_id}, {sleep_service.get_sleep_id()}, NOW(), 0, 0)")

    def worker(self):
        while True:
            audio_chunk = self.record_chunk()
            sd.wait()
            volume = self.get_volume(audio_chunk)
            self.pre_buffer.append(audio_chunk)
            self.warmup_counter = self.warmup_counter + 1
            
            if self.warmup_counter < 5:
                continue
            
            is_sleeping = sleep_service.is_sleeping
            slept_since = sleep_service.sleeping_since
            config_before_sleep_delay = configuration_manager.get_config("MICRO","before_sleep_delay_minutes") * 60
            
            if not is_sleeping or (time.time() - slept_since) < config_before_sleep_delay:
                self.print("Not sleeping or not slept long enough, skipping recording.")
                self.print("Sleeping status:", is_sleeping)
                self.print("Recording starts in:", max(config_before_sleep_delay - (time.time() - slept_since), 0), "seconds")
                time.sleep(5)
                continue
            
            if volume > THRESHOLD:
                if not self.recording:
                    self.print("Starting recording...")
                    self.recording = True
                    self.recording_buffer.extend(self.pre_buffer)
                    self.post_timer = self.post_buffer_chunks
                else:
                    self.print("Extending recording...")
                    self.post_timer = self.post_buffer_chunks

                self.recording_buffer.append(audio_chunk)
                
            elif self.recording:
                if self.post_timer > 0:
                    self.recording_buffer.append(audio_chunk)
                    self.post_timer -= 1
                else:
                    self.print("Saving recording...")
                    audio_data = np.concatenate(self.recording_buffer)
                    filename = f"recording_{int(time.time())}.wav"
                    self.upload_buffer(audio_data, filename)
                    print(f"Saved: {filename}")

                    self.recording = False
                    self.recording_buffer = []
                
recordings_service = RecordingsService()